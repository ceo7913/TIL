## JavaScript(Es6)
Es6(ECMAScript6) = 2016년에 나온 자바스크립트의 버전
1. 변수 추가 = let, const (var 는 사용하지 않도록 권장)
2. 함수의 작성법이 추가(화살표 함수)
3. 새로운 문법(템플릿 리터럴)
4. 새로운 메서드 추가
 react 와 같은 새로운 라이브러리가 es6문법에 최적화 되어 있으므로 리액트를 배우기 위해서는
 es6가 선행되어야 한다. 

### 변수 추가 = let, const (var 는 사용하지 않도록 권장)
#### 변수가 생성되는 과정
1. 선언
- 변수를 실행 / 함수에 등록
2. 초기화
- 변수명 안에 값이 들어갈 경우 공간을 만들기 위해서 영역을 확보
이 단계에서는 undefined 가 출력됨
3. 값의 할당
undefined 로 초기화된 변수에 값이 들어가진다.

var 는 1, 2번을 동시 실행 하기 때문에 변수를 등록하고 공간을 확보하는 과정에서  
값을 참조하려 하기 때문에 변수를 선언하기 전에 값을 호출해도 에러가 아닌 undefined 를 출력함  
이 현상을 변수 호이스팅이라고 한다.   

let 과 const 는 다른 프로그래밍 언어와 같은 블록레벨 스코프(함수레벨스코프도 있다. 이것은  
범위를 의미하며 변수가 인식하는 범위이다.) 단위의 변수 키워드  

#### 변수 스코프의 종류
> 블록레벨 스코프
>> if, for, while 이 있는데 선언되는 변수는 블록내에서만 유효한 변수여야 한다.  
밖에서는 호출할 수 없고, 블록레벨 내에서 선언되는 변수는 모두 지역변수이다.

> 함수레벨 스코프(var)
>> 함수 내에서 선언된 변수는 함수 내에서만 사용하며, 함수 밖으로 호출할 수 없다.  
함수내에서 선언된 변수는 모두 지역변수, 밖에서 선언된 변수는 모두 전역 변수

#### 함수레벨 스코프의 단점
- 범위를 예측하기 어려워진다. => 사용범위 넓어짐 즉 오류의 범위도 넓어짐
- 전역변수보다 지역변수의 사용이 적어질 수 있다.
- 호이스팅 문제가 많이 발생한다. (1번과 비슷한 맥락)

#### let, const = 블록레벨 변수 스코프
- let : 재선언 불가능, 값의 재할당은 가능, 호이스팅 불가능
- const : 재선언 불가능, 값의 재할당 불가능, 호이스팅 불가능 => 때문에 값이 변하지 않는 상수를 많이 할당
보통적으로 값이 많이 변하는 경우가 많이 없기 때문에 const 를 기본적으로 할당 후 let 으로 변경하는 방법이 좋다.


### 2. 함수의 작성법이 추가(화살표 함수)
기존 함수에서의 this는 함수를 호출하는 객체  
화살표 함수에서는 항상 화살표 함수를 정의한 객체를 this 로 본다.  

#### JavaScript(this)
this 는 생성자 혹은 메소드에서 객체를 가리킬 때 사용하는 키워드이다.

#### this 의 사용
- 새로 만들어지는 객체에 생성자의 속성을 넣어줄 때
- 객체의 속성에 접근(메소드에서 사용하는 this)할 때
```
let a = this; 
console.log(a); // Window
```
전역변수의 this => 이런경우는 참조하는 함수가 없기 때문에 window 를 가르킨다.  
document 가 아닌이유는 문서상에서 호출하지 않기 때문이다.  

this 는 때에 따라 다른 값을 가리킨다. 어떠한 문맥이냐에 따라서 그 값이 바뀐다.
1. global scope 에서 사용될 때 this 는 전역 객체를 가리킨다.(window 객체)
2. 함수에서 사용될 때에도 this 는 전역 객체를 가리킨다.
3. 객체에 속한 메소드에서 사용될 때 this 는 메소드가 속한 객체를 가리킨다.
4. 객체에 속한 메소드의 내부함수에서 사용될 때 this 는 전역 객체를 가리킨다.
5. 생성자에서 사용될 때 this 는 이 생성자로 인해 생성된 새로운 객체를 가리킨다.

### 화살표 함수 (this)
* 화살표 함수는 다음과 같은 특징을 가지고 있다.
* 화살표 함수는 익명 함수로만 만들 수 있다.
* 화살표 함수는 생성자로 사용할 수 없다.
* 화살표 함수는 스스로의 this, argument 를 가지지 않는다.
* 함수가 정의된 스코프에 존재하는 this 를 가리킨다.
* 화살표 함수는 생성될 때 this 가 결정된다.
* 화살표 함수가 어떻게 사용되건, 호출되건, this 는 바뀌지 않는다.

#### 기본적인 함수 표현식
```
function test01(){
    console.log('test01');
}
test01()
```

#### 변수에 함수를 담아서 표현 => 변수 선언식
```
let test02 = function(){
    console.log('test02');
}
test02()
```
- Es6 에서 새로 추가된 화살표 함수
앞에 let 이나 const 같은 scope 를 붙히는 경우도 있는데 react 에서 자주 사용하고  
호출 방식은 같기 때문에 어떤 방식이는 문제는 없다.  
다만 test03 이 함수로 호출되냐 let,const 를 가지고 변수로 호출되냐의 차이는 있다.    
        
일반 함수에서 this 는 자신을 호출한 객체를 this 로 인식하지만  
화살표 함수에서는 **항상** window 를 참조한다.  


```
test03 = () =>{ // '=>' 가 function 의 의미를 같는다.
    console.log('test03');
}
test03();
```

* 표현식의 내용이 하나인 경우 {} 를 생략해도 된다.
```
test04 = () => console.log('test04');
test04();
```

* 매개변수가 들어가는 경우
```
test05 = (x) => console.log(x*x);
test05(10); 

test06 = x => console.log(x*x);
test06(3);
```
매개변수의 값이 하나일때에는 () 가 생략되어도 된다.


#### 화살표 함수와 일반함수의 차이점
화살표 함수 = 간단한 기능이나 일관된 값을 유지하는 로직  
로직이 복잡해지면 this 를 사용해야 되는경우가 있는데 이럴때는 단점

일반함수 = 복잡한 로직, 생성자 및 객체를 사용해야 할 때   
일반함수에서의 this 는 인스턴스를 의미

사용범위가 나눠지는 이유는 this 의 범위가 다르기 때문이다.

