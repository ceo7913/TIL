## JS 자료구조/알고리즘 (코딩테스트)

### 자신만의 소스 코드 관리
- 알고리즘 코딩 테스트를 준비하며 **자신만의 코드템플릿**을 만드는 것이 유리
- 대표적인 알고리즘(정렬, 최단 경로 등)의 기본형에 대하여 미리 코드를 구현하는 것이 좋음
- 자신의 코드를 라이브러리화하여 GitHub 에서 관리하는 것을 추천
- 예시) https://github.com/ndb796/Pyhon-Competitive-Programming-Team-Notes

### IT 기업 코딩 테스트 출제 경향
- 대부분 IT 대기업은 공개 채용 과정에서 알고리즘 코딩 테스트를 시행
- 응시생들에게 2~5시간 가량의 시간을 주어 여러 개의 정해진 알고리즘 문제들을 풀도록 함
- 구현, DFS/BFS(탐색), 탐욕 알고리즘 유형이 출제 빈도가 높은 편

### 올바른 준비
- 적절한 프로그래밍 언어 선택
- 알고리즘 유형별로 이론 및 핵심 문제를 10개 이상 풀어보기
> 대표적인 알고리즘 유형: 정렬, DFS/BFS, 구현, 완전 탐색, 탐용 알고리즘
- 원하는 기업의 기출(혹은 유사한) 문제 풀기

### 시간 복잡도
- 시간 복잡도는 알고리즘의 성능을 나타내는 척도
- 시간 복잡도: 특정한 크기의 입력에 대하여 알고리즘의 수행 시간 분석
> 여기서 "복잡도" 라는 단어는 일반적으로 "복잡"하다라고 말하는거랑은 조금 다른 개념
> 엄밀히 말하면 계산복잡도 이론에서 출발한 내용으로 쉽게 말하면, 조금 더 값이 크게 증가하는 정도라고 보면 된다.("크게 증가하는 정도" 즉 크기에 대한 개념에 가깝고 "코드가 복잡하다 알아보기 힘들다" 보다는)
> 수치적으로 값이 얼마나 큰가 이런 부분에 조금 더 초점이 맞춰져 있다. 
>> 그냥 궁금해서 구글링해봤다
>> "시간 복잡도가 낮을 수록 렌더링이 더 빠른가?"
>> 
>> **시간 복잡도가 낮다고 해서 반드시 렌더링 속도가 빨라지는 것은 아닙니다.** 시간 복잡도는 알고리즘의 계산 효율성을 나타내며 입력 크기가 커짐에 따라 알고리즘의 실행 시간이 어떻게 증가하는지 설명합니다. 입력 크기를 기반으로 문제를 해결하는 데 필요한 작업 수를 추정합니다. 시간 복잡도가 낮다는 것은 일반적으로 더 큰 입력 크기에 대해 알고리즘이 더 빠르게 실행된다는 것을 나타내지만 렌더링 속도와 직접적인 상관 관계는 없습니다. 렌더링에는 알고리즘의 시간 복잡도 이외의 요인에 의해 영향을 받는 형상 계산, 음영 처리, 텍스처링 및 래스터화와 같은 복잡한 프로세스가 포함됩니다. 렌더링 속도는 장면의 복잡성, 렌더링 엔진의 기능, 하드웨어 성능(예: 그래픽 카드), 메모리 대역폭 및 렌더링 파이프라인에 특정한 기타 최적화를 비롯한 다양한 요인에 따라 달라집니다. 시간 복잡도가 낮은 렌더링 알고리즘은 효율성 향상을 제공할 수 있지만 병렬 처리, 메모리 관리 및 알고리즘 최적화와 같은 다른 측면도 렌더링 속도에 영향을 줄 수 있습니다. 요약하면 시간 복잡도는 알고리즘 설계 및 성능에 중요한 고려 사항이지만 렌더링 속도를 결정하는 유일한 요소는 아닙니다. 렌더링은 단순한 알고리즘 복잡성을 넘어서는 여러 구성 요소 및 최적화를 포함하는 복잡한 작업입니다.

- 동일한 기능을 수행하는 알고리즘이 있다면, 일반적으로 복잡도가 낮을수록 우수 (알고리즘이 돌아가는데 시간이 빠르다. 결과가 금방 나온다.)
 
### 빅오 표기법(Big-O Notation)
- 가장 빠르게 증가하는 항만을 고려하는 표기법
- 함수의 상한을 나타낸다. 
> 예를 들어 연산횟수가 3N^3 + 5N^2 + 1,000,000 인 알고리즘이 있다고하자.
> _N_이 증가함에 따라서, 3N^3 을 제외한 다른 항의 영향력은 작아진다.
> Big-O 표기법에서는 차수가 가장 큰 항에서 계수를 지외하여 O(N^3)으로 표현된다.
>
