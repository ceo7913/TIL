## JS 자료구조/알고리즘 (코딩테스트)

### 자신만의 소스 코드 관리
- 알고리즘 코딩 테스트를 준비하며 **자신만의 코드템플릿**을 만드는 것이 유리
- 대표적인 알고리즘(정렬, 최단 경로 등)의 기본형에 대하여 미리 코드를 구현하는 것이 좋음
- 자신의 코드를 라이브러리화하여 GitHub 에서 관리하는 것을 추천
- 예시) https://github.com/ndb796/Pyhon-Competitive-Programming-Team-Notes

### IT 기업 코딩 테스트 출제 경향
- 대부분 IT 대기업은 공개 채용 과정에서 알고리즘 코딩 테스트를 시행
- 응시생들에게 2~5시간 가량의 시간을 주어 여러 개의 정해진 알고리즘 문제들을 풀도록 함
- 구현, DFS/BFS(탐색), 탐욕 알고리즘 유형이 출제 빈도가 높은 편

### 올바른 준비
- 적절한 프로그래밍 언어 선택
- 알고리즘 유형별로 이론 및 핵심 문제를 10개 이상 풀어보기
> 대표적인 알고리즘 유형: 정렬, DFS/BFS, 구현, 완전 탐색, 탐용 알고리즘  
- 원하는 기업의 기출(혹은 유사한) 문제 풀기

### 시간 복잡도
- 시간 복잡도는 알고리즘의 성능을 나타내는 척도
- 시간 복잡도: 특정한 크기의 입력에 대하여 알고리즘의 수행 시간 분석
> 여기서 "복잡도" 라는 단어는 일반적으로 "복잡"하다라고 말하는거랑은 조금 다른 개념  
> 엄밀히 말하면 계산복잡도 이론에서 출발한 내용으로 쉽게 말하면, 조금 더 값이 크게 증가하는 정도라고 보면 된다.("크게 증가하는 정도" 즉 크기에 대한 개념에 가깝고 "코드가 복잡하다 알아보기 힘들다" 보다는)  
> 수치적으로 값이 얼마나 큰가 이런 부분에 조금 더 초점이 맞춰져 있다.   
>> 그냥 궁금해서 구글링해봤다  
>> "시간 복잡도가 낮을 수록 렌더링이 더 빠른가?"  
>> **시간 복잡도가 낮다고 해서 반드시 렌더링 속도가 빨라지는 것은 아닙니다.** 시간 복잡도는 알고리즘의 계산 효율성을 나타내며 입력 크기가 커짐에 따라 알고리즘의 실행 시간이 어떻게 증가하는지 설명합니다. 입력 크기를 기반으로 문제를 해결하는 데 필요한 작업 수를 추정합니다. 시간 복잡도가 낮다는 것은 일반적으로 더 큰 입력 크기에 대해 알고리즘이 더 빠르게 실행된다는 것을 나타내지만 렌더링 속도와 직접적인 상관 관계는 없습니다. 렌더링에는 알고리즘의 시간 복잡도 이외의 요인에 의해 영향을 받는 형상 계산, 음영 처리, 텍스처링 및 래스터화와 같은 복잡한 프로세스가 포함됩니다. 렌더링 속도는 장면의 복잡성, 렌더링 엔진의 기능, 하드웨어 성능(예: 그래픽 카드), 메모리 대역폭 및 렌더링 파이프라인에 특정한 기타 최적화를 비롯한 다양한 요인에 따라 달라집니다. 시간 복잡도가 낮은 렌더링 알고리즘은 효율성 향상을 제공할 수 있지만 병렬 처리, 메모리 관리 및 알고리즘 최적화와 같은 다른 측면도 렌더링 속도에 영향을 줄 수 있습니다. 요약하면 시간 복잡도는 알고리즘 설계 및 성능에 중요한 고려 사항이지만 렌더링 속도를 결정하는 유일한 요소는 아닙니다. 렌더링은 단순한 알고리즘 복잡성을 넘어서는 여러 구성 요소 및 최적화를 포함하는 복잡한 작업입니다.

- 동일한 기능을 수행하는 알고리즘이 있다면, 일반적으로 복잡도가 낮을수록 우수 (알고리즘이 돌아가는데 시간이 빠르다. 결과가 금방 나온다.)
 
### 빅오 표기법(Big-O Notation)
- 가장 빠르게 "증가하는 항" 만을 고려하는 표기법(*항이란? 전체를 여러 개의 구성 요소로 나누었을 때, 그 각각을 뜻함 => 아래 예시처럼 (3N^3 + 5N^2 + 1,000,000)의 경우 3N^3, 5N^2, 1,000,000가 각각의 항이다.)
- Notation = 표기법
- 함수의 상한을 나타낸다. 
> 예를 들어 연산횟수가 3N^3 + 5N^2 + 1,000,000 인 알고리즘이 있다고하자.  
>> 이때 데이터의 크기가 _N_ 이라고 하면 _N_ 이 증가함에 따라서 이 항 중에서 어떤 항이 가장 빠르게 증가할까? (이때 가장 빠르게 증가한다고 함은 차수(문자를 포함한 항에서 문자가 곱해진 개수를 의미)가 높은걸 의미) 따라서 (3N^3) 3제곱 즉 차수가 가장 높은건 (3N^3) / **다른 항들에 비해 _N_ 이라는 변수가 주는 영향이 크다.**  
>> 여기서 Big-O 표기법이 가장 빠르게 증가하는 항 만을 고려하는 표기법  
> _N_ 이 증가함에 따라서, 3N^3 을 제외한 다른 항의 영향력은 작아진다.  
> Big-O 표기법에서는 차수가 가장 큰 항에서 계수를 지외하여 O(N^3)으로 표현된다.  

#### Big-O Notation (**가장 빠르게 증가하는 항**만을 고려하는 표기법)
|-|시간 복잡도|의미|
|:---:|:---:|:---:|
|좋음(Better)|0(1)|상수 시간(constant time)|
|-|0(LogN)|로그 시간(log time)|
|-|0(N)|선형 시간(linear time)|
|-|0(NlogN)|로그 선형 시간(log-linear time)|
|-|0(N^2)|이차 시간(quadratic time)|
|-|0(N^3)|삼차 시간(cubic time)|
|나쁨(Worse)|0(2^N)|지수 시간(exponential time)|

* log? (로그(log)는 지수 함수의 역함수로, 로가리듬(영어: Logarithm)의 줄임말이다. 어떤 수를 나타내기 위해 고정된 밑을 몇 번 곱하여야 하는지를 나타낸다고 볼 수 있다.)

#### 시간 복잡도 예시 1)
- _N_ 개의 데이터의 합을 계산하는 프로그램 예제
```
let array = [3, 5, 1, 2, 4]; // 5개의 데이터 (N=5)
let summary = 0; // 합게를 저장할 변수

// 모든 데이터를 하나씩 확인하며, 합계를 계산
for(let i = 0; i < array.length; i ++){
    summary += array[i];
}

// 결과 출력
console.log(summary);
```
- 수행 시간은 데이터의 개수 _N_ 에 비래할 것임을 예측할 수 있다.
- 시간 복잡도: _O_(N)

#### 시간 복잡도 예시 2)
- 2중 반복 문법을 이용하는 프로그램 예제
```
let array = [3, 5, 1, 2, 4]; // 5개의 데이터 (N=5)

for(let i = 0; i < array.length; i ++){
    // 2중 포문이기 때문에 i 가 한번 바뀔 때 마다 j 는 5번씩 돌아간다. 때문에 결과적으로 5*5 => 총 25번 만큼 곱셈 연산이 수행됨
    for(let j = 0; j < array.length; i ++){
        let tamp = array[i] * array[j];'
        console.log(temp);
    }
}
```
- 시간 복잡도: _O_(N^2)
- [참고] 모든 2중 반복 문법의 시간 복잡도가 _O_(N^2)인 것은 아니다.
- 소스코드가 내부적으로 다른 함수를 호출한다면 그 함수도 고려해야 한다.
- 때문에 소스코드를 분석해서 실질적으로 데이터의 개수가 _N_ 일 때 얼마만큼 반복이 수행되는지에 대해서 시간복잡도를 체크

### 알고리즘 설계 Tip
- 일반적인 CPU 기반의 개인 컴퓨터나 채점 목적의 컴퓨터를 고려해 보자
- JS 를 기준으로 1억번의 연산을 처리하기 위해 1~5초 가량의 시간이 소요된다.
- _O_(N^3)의 알고리즘을 설계한 경우, _N_ 의 값이 5,000이 넘는다면 얼마나 걸릴까?(대략 125억 따라서 100초가 넘는 알고리즘이 된다.)
> 시간 복잡도가 O(N^3)인 알고리즘이 있다면 입력 크기의 세제곱에 따라 알고리즘을 실행하는 데 걸리는 시간이 증가한다는 의미입니다. 이 경우 N 값이 5,000 이상이면 다음과 같이 실행 시간을 추정할 수 있다.  
> N = 5,000의 실행 시간이 T초라고 가정하면, N 을 N + 1로 늘리면 실행 시간은 대략 (N + 1)^3 / 5,000^3 * T초가 된다.  
> N = 5,000에 대한 실행 시간을 계산 (T = 5,000^3 * T(N = 5,000이므로) T = 125,000,000,000 * T)  
> N = 5,001에 대한 실행 시간을 계산 ((N + 1)^3 / 5,000^3 * T = (5,001^3 / 5,000^3) * 125,000,000,000 * T ≈ 1.0006 * 125,000,000,000 * T)  
> 이 계산에서 N = 5,001에 대한 실행 시간은 N = 5,000에 대한 실행 시간의 약 1.0006배임을 알 수 있다. 이것은 실행 시간의 증가가 상대적으로 작다는 것을 의미  
> 이 패턴을 계속해서 N 을 5,000보다 훨씬 큰 값으로 늘리면 실행 시간은 계속 증가하지만 증가 속도는 느려진다. 이는 시간 복잡도가 3차이고 2차 또는 지수 복잡도에 비해 실행 시간이 더 느린 속도로 증가하기 때문이다.  
> 따라서 5,000을 초과하는 N 값의 경우 실행 시간이 더 작은 N 값보다 훨씬 더 길지만 O와 같은 더 높은 시간 복잡성에 비해 여전히 관리 가능하다고 말할 수 있다. (2^N) 또는 O(N!)  
- 코딩 테스트 문제에서 시간 제한은 통상 1~5초 가량이다.
- 문제에 명시되어 있지 않은 경우 대략 5초 정도라고 생각하고 문제를 푸는 것이 합리적
#### 요구사항에 따라 적절한 알고리즘 설계하기
- 문제에서 가장 먼저 호가인해야 하는 내용은 시간제한(수행 시간 요구사항)이다.
- **시간제한이 1초**인 문제를 만났을 때, 일반적인 기준은 다음과 같다.
> _N_ 의 범위가 500인 경우: 시간 복잡도가 _O_(_N_^3)인 알고리즘을 설계하면 문제를 풀 수 있다.  
> _N_ 의 범위가 2000인 경우: 시간 복잡도가 _O_(_N_^2)인 알고리즘을 설계하면 문제를 풀 수 있다.  
> _N_ 의 범위가 100,000인 경우: 시간 복잡도가 _O_(_N_ log _N_)인 알고리즘을 설계하면 문제를 풀 수 있다.  
> _N_ 의 범위가 10,000,000인 경우: 시간 복잡도가 _O_(_N_)인 알고리즘을 설계하면 문제를 풀 수 있다.  
